Possiveis funcionalidades do C# 6.0

Sei que para alguns desenvolvedores este post será visto como notícia velha, mas eu me deparei com estas informaçoes hoje e as achei bem interessante, assim sendo, decidi postar sobre o assunto (mesmo porque não encontrei muito sobre o assunto em português).

Se você deseja ver os posts onde encontrei tais informações (em inglês) veja [http://damieng.com/blog/2013/12/09/probable-c-6-0-features-illustrated][estes] [http://wesnerm.blogs.com/net_undocumented/2013/12/mads-on-c-60.html][links] (ambos são baseados em um evento da Microsoft que ocorreu em Londres chamado [http://ndclondon.oktaset.com/t-11783][NDC] que ocorreu em Dez/2013).

Os comentários representam a minha opnião (que pode não representar nada para você :)) e eu não sou, de forma alguma, um especialista em linguagens de programação (por exemplo não fiz esforço algum para verificar se as minhas sugestões não introduziriam ambiguidades na sintaxe da linguagem).

{ DefaultProcessors:[SyntaxHighlight, HtmlEncode] }

----
"Primary constructors"

C# 5.0

{ CSharp6/5.0/PrimaryConstructors.cs }

C# 6.0

{ CSharp6/6.0/PrimaryConstructors.cs }

- Não ficou claro para mim
	- será possível ter um corpo no construtor ?
	- paramêtros com valor default ?
	- assume a mesma visibilidade da classe ?
	- será possivel definir outros construtores ?

- Já que o objetivo é simplificar porque não introduzir um conceito tipo "campos automáticos" ou mesmo "propriedades automáticas" permitindo assim
  reescrever o exemplo como: 

{ CSharp6/6.0/PrimaryConstructors.cs@primary-ctor-proposal }
class Exemplo (int valor, string nome) // Isto definiria os campos valor e nome.
{
}

----
Propriedades (automaticas) somente leitura 

C# 6.0

class Exemplo1
{
	public int PropriedadeSomenteLeitura { get; } = campo;
}

C# 5.0

class Exemplo1
{
	private int campo;
	public int PropriedadeSomenteLeitura { get { return campo; } }
}

Eu realmente não vejo muito ganho com isto. Eu prefiro a versão abaixo (já suportada atualment é claro)
(ok, eu sei que as mesmas não semanticamente equivalentes)

class Exemplo1
{
	public int PropriedadeSomenteLeitura { get; private set; }
}

- O que pode ser usado como valor da propriedade? Qualquer expressão? 

class Exemplo1
{
	public int PropriedadeSomenteLeitura { get; } = um_campo_qualquer * UmMethodQualquer(1.0);
}

----
"Using" para membros estáticos

C# 6.0

using System.Math;
class Exemplo1
{
	public double M()
	{
		return Sqrt(1.0, 4.2);
	}
}

C# 5.0

using System;
class Exemplo1
{
	public double M()
	{
		return Math.Sqrt(1.0, 4.2);
	}
}

Sério? Java já suporta este recurso a algum tempo... e eu nunca gostei muito do mesmo... :(


----
Property Expressions (cara, não sei nem como traduzir isso)

C# 6.0

class Exemplo1
{
	public decimal ValorTotal => Quantidade * ValorUnitario;
}

C# 5.0

class Exemplo1
{
	public decimal ValorTotal { get { return Quantidade * ValorUnitario ; } }
}

Ok, na minha opnião vivemos muito bem sem este recurso.

Péssimo nome (vai causar confusão)


----
"Method expressions"

C# 6.0

class Exemplo1
{
	public Point Move(int dx, int dy) => new Point(X + dx, Y + dy);
}


C# 5.0

class Exemplo1
{
	public Point Move(int dx, int dy) 
	{ 
		return new Point(X + dx, Y + dy); 
	}
}

Hum... 


----
Enumerables como parâmetros do tipo "params"

C# 6.0

class Exemplo1
{
	public void FazAlgo(params IEnumerable<MeuTipo> items) { }
}

C# 5.0

class Exemplo1
{
	public void FazAlgo(params []MeuTipo items) { }
}

Ok, dessa eu gostei pois não me obriga criar arrays só para poder chamar métodos como no exemplo acima (lembre-se que arrays em C# implementam IEnumerable<T> então, passar arrays, para métodos definidos como o exemplo acima, não exige conversões!

----
Checagem de "null" mais inteligente (ou "monadic null checking", o que quer que isso queira dizer ;)

C# 6.0

class Exemplo1
{
	public int M(IList<string> ss)
	{
		return ss?.FirstOrDefault()?.Length ?? -1;
	}
}

C# 5.0

class Exemplo1
{
	public int M(IList<string> ss)
	{
		if (ss != null)
		{
		 	var primeiraOuNulo = ss.FirstOrDefault();
		 	if (primeiraOuNulo != null)
		 		return primeiraOuNulo.Length;
		}
		return -1;
	}
}

Vamos acabar com o Natal! (afinal de contas, este tipo de sintaxe ajudaria em muito a por um fim em código tipo arvore de natal).

----
Inferência de tipos a partir de parêmtros de construtores

C# 6.0

void M()
{
	var l = new List { "Lista", "de", "strings" };
}

C# 5.0

void M()
{
	var l = new List<string> { "Lista", "de", "strings" };
}

Preciso dizer algo? Mais um ponto para os designer da linguagem

----
Declaração "inline" para parâmetros "out"

C# 6.0

void M()
{
	return Int32.TryParse("42", out int valor) ? valor : -1;
}

C# 5.0

void M()
{
	int valor;
	if(Int32.TryParse("42", out valor))
		return valor;

	return -1;
}

------

Algumas funcionalidades que eu realmente gostaria de ver na próxima versão do C#!

- Interpolação de strings

- Classes anônimas implementando interfaces.

- Pattern matching ????

- Extension properties !!!!


Boa programação!